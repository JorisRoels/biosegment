/* tslint:disable */
/* eslint-disable */
/**
 * BioSegment
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Annotation
 */
export interface Annotation {
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    location?: string;
    /**
     * 
     * @type {AnnotationFileType}
     * @memberof Annotation
     */
    file_type?: AnnotationFileType;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface AnnotationCreate
 */
export interface AnnotationCreate {
    /**
     * 
     * @type {string}
     * @memberof AnnotationCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationCreate
     */
    location?: string;
    /**
     * 
     * @type {AnnotationFileType}
     * @memberof AnnotationCreate
     */
    file_type?: AnnotationFileType;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum AnnotationFileType {
    Json = 'json'
}

/**
 * 
 * @export
 * @interface AnnotationUpdate
 */
export interface AnnotationUpdate {
    /**
     * 
     * @type {string}
     * @memberof AnnotationUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationUpdate
     */
    location?: string;
    /**
     * 
     * @type {AnnotationFileType}
     * @memberof AnnotationUpdate
     */
    file_type?: AnnotationFileType;
    /**
     * 
     * @type {{ [key: string]: Array<object>; }}
     * @memberof AnnotationUpdate
     */
    shapes?: { [key: string]: Array<object>; };
}
/**
 * 
 * @export
 * @interface BodyCreateUserOpenApiV1UsersOpenPost
 */
export interface BodyCreateUserOpenApiV1UsersOpenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    full_name?: string;
}
/**
 * 
 * @export
 * @interface BodyLoginAccessTokenApiV1LoginAccessTokenPost
 */
export interface BodyLoginAccessTokenApiV1LoginAccessTokenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyLoginAccessTokenApiV1LoginAccessTokenPost
     */
    grant_type?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginAccessTokenApiV1LoginAccessTokenPost
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginAccessTokenApiV1LoginAccessTokenPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginAccessTokenApiV1LoginAccessTokenPost
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginAccessTokenApiV1LoginAccessTokenPost
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginAccessTokenApiV1LoginAccessTokenPost
     */
    client_secret?: string;
}
/**
 * 
 * @export
 * @interface BodyResetPasswordApiV1ResetPasswordPost
 */
export interface BodyResetPasswordApiV1ResetPasswordPost {
    /**
     * 
     * @type {string}
     * @memberof BodyResetPasswordApiV1ResetPasswordPost
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof BodyResetPasswordApiV1ResetPasswordPost
     */
    new_password: string;
}
/**
 * 
 * @export
 * @interface BodyUpdateUserMeApiV1UsersMePut
 */
export interface BodyUpdateUserMeApiV1UsersMePut {
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    description?: string;
    /**
     * 
     * @type {DatasetFileType}
     * @memberof Dataset
     */
    file_type?: DatasetFileType;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    location?: string;
    /**
     * 
     * @type {Resolution}
     * @memberof Dataset
     */
    resolution?: Resolution;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    modality?: string;
    /**
     * 
     * @type {number}
     * @memberof Dataset
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Dataset
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface DatasetCreate
 */
export interface DatasetCreate {
    /**
     * 
     * @type {string}
     * @memberof DatasetCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetCreate
     */
    description?: string;
    /**
     * 
     * @type {DatasetFileType}
     * @memberof DatasetCreate
     */
    file_type?: DatasetFileType;
    /**
     * 
     * @type {string}
     * @memberof DatasetCreate
     */
    location?: string;
    /**
     * 
     * @type {Resolution}
     * @memberof DatasetCreate
     */
    resolution?: Resolution;
    /**
     * 
     * @type {string}
     * @memberof DatasetCreate
     */
    modality?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum DatasetFileType {
    Tif2d = 'tif2d',
    Tif3d = 'tif3d',
    Tifseq = 'tifseq',
    Pngseq = 'pngseq'
}

/**
 * 
 * @export
 * @interface DatasetUpdate
 */
export interface DatasetUpdate {
    /**
     * 
     * @type {string}
     * @memberof DatasetUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetUpdate
     */
    description?: string;
    /**
     * 
     * @type {DatasetFileType}
     * @memberof DatasetUpdate
     */
    file_type?: DatasetFileType;
    /**
     * 
     * @type {string}
     * @memberof DatasetUpdate
     */
    location?: string;
    /**
     * 
     * @type {Resolution}
     * @memberof DatasetUpdate
     */
    resolution?: Resolution;
    /**
     * 
     * @type {string}
     * @memberof DatasetUpdate
     */
    modality?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface ItemCreate
 */
export interface ItemCreate {
    /**
     * 
     * @type {string}
     * @memberof ItemCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCreate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ItemUpdate
 */
export interface ItemUpdate {
    /**
     * 
     * @type {string}
     * @memberof ItemUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    location?: string;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface ModelCreate
 */
export interface ModelCreate {
    /**
     * 
     * @type {string}
     * @memberof ModelCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCreate
     */
    location?: string;
}
/**
 * 
 * @export
 * @interface ModelCreateFromAnnotation
 */
export interface ModelCreateFromAnnotation {
    /**
     * 
     * @type {Array<number>}
     * @memberof ModelCreateFromAnnotation
     */
    orientations?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    device?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    print_stats?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    fm?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    levels?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    dropout?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCreateFromAnnotation
     */
    norm?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCreateFromAnnotation
     */
    activation?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    in_channels?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCreateFromAnnotation
     */
    loss?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    lr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    step_size?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    gamma?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    epochs?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    len_epoch?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    test_freq?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    train_batch_size?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    test_batch_size?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCreateFromAnnotation
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCreateFromAnnotation
     */
    location: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCreateFromAnnotation
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    from_model_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCreateFromAnnotation
     */
    annotation_id: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ModelCreateFromAnnotation
     */
    classes_of_interest: Array<number>;
}
/**
 * 
 * @export
 * @interface ModelUpdate
 */
export interface ModelUpdate {
    /**
     * 
     * @type {string}
     * @memberof ModelUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelUpdate
     */
    location?: string;
}
/**
 * 
 * @export
 * @interface Msg
 */
export interface Msg {
    /**
     * 
     * @type {string}
     * @memberof Msg
     */
    msg: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    start_date?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    stop_date?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface ProjectCreate
 */
export interface ProjectCreate {
    /**
     * 
     * @type {string}
     * @memberof ProjectCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCreate
     */
    start_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCreate
     */
    stop_date?: string;
}
/**
 * 
 * @export
 * @interface ProjectUpdate
 */
export interface ProjectUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProjectUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectUpdate
     */
    start_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectUpdate
     */
    stop_date?: string;
}
/**
 * 
 * @export
 * @interface Resolution
 */
export interface Resolution {
    /**
     * 
     * @type {number}
     * @memberof Resolution
     */
    x: number;
    /**
     * 
     * @type {number}
     * @memberof Resolution
     */
    y: number;
    /**
     * 
     * @type {number}
     * @memberof Resolution
     */
    z: number;
}
/**
 * 
 * @export
 * @interface Segmentation
 */
export interface Segmentation {
    /**
     * 
     * @type {string}
     * @memberof Segmentation
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Segmentation
     */
    description?: string;
    /**
     * 
     * @type {SegmentationFileType}
     * @memberof Segmentation
     */
    file_type?: SegmentationFileType;
    /**
     * 
     * @type {string}
     * @memberof Segmentation
     */
    location?: string;
    /**
     * 
     * @type {number}
     * @memberof Segmentation
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Segmentation
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface SegmentationCreate
 */
export interface SegmentationCreate {
    /**
     * 
     * @type {string}
     * @memberof SegmentationCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentationCreate
     */
    description?: string;
    /**
     * 
     * @type {SegmentationFileType}
     * @memberof SegmentationCreate
     */
    file_type?: SegmentationFileType;
    /**
     * 
     * @type {string}
     * @memberof SegmentationCreate
     */
    location?: string;
}
/**
 * 
 * @export
 * @interface SegmentationCreateFromModel
 */
export interface SegmentationCreateFromModel {
    /**
     * 
     * @type {string}
     * @memberof SegmentationCreateFromModel
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentationCreateFromModel
     */
    description?: string;
    /**
     * 
     * @type {SegmentationFileType}
     * @memberof SegmentationCreateFromModel
     */
    file_type?: SegmentationFileType;
    /**
     * 
     * @type {string}
     * @memberof SegmentationCreateFromModel
     */
    location: string;
    /**
     * 
     * @type {number}
     * @memberof SegmentationCreateFromModel
     */
    model_id: number;
    /**
     * 
     * @type {number}
     * @memberof SegmentationCreateFromModel
     */
    dataset_id: number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum SegmentationFileType {
    Tif2d = 'tif2d',
    Tif3d = 'tif3d',
    Tifseq = 'tifseq',
    Pngseq = 'pngseq'
}

/**
 * 
 * @export
 * @interface SegmentationUpdate
 */
export interface SegmentationUpdate {
    /**
     * 
     * @type {string}
     * @memberof SegmentationUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentationUpdate
     */
    description?: string;
    /**
     * 
     * @type {SegmentationFileType}
     * @memberof SegmentationUpdate
     */
    file_type?: SegmentationFileType;
    /**
     * 
     * @type {string}
     * @memberof SegmentationUpdate
     */
    location?: string;
}
/**
 * 
 * @export
 * @interface Shapes
 */
export interface Shapes {
    /**
     * 
     * @type {{ [key: string]: Array<object>; }}
     * @memberof Shapes
     */
    shapes?: { [key: string]: Array<object>; };
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    task_id: string;
}
/**
 * 
 * @export
 * @interface TaskState
 */
export interface TaskState {
    /**
     * 
     * @type {string}
     * @memberof TaskState
     */
    state: string;
    /**
     * 
     * @type {number}
     * @memberof TaskState
     */
    current?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskState
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    access_token: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token_type: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    full_name?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * AnnotationsApi - axios parameter creator
 * @export
 */
export const AnnotationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new annotation.
         * @summary Create Annotation
         * @param {AnnotationCreate} annotationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnotationApiV1AnnotationsPost: async (annotationCreate: AnnotationCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'annotationCreate' is not null or undefined
            if (annotationCreate === null || annotationCreate === undefined) {
                throw new RequiredError('annotationCreate','Required parameter annotationCreate was null or undefined when calling createAnnotationApiV1AnnotationsPost.');
            }
            const localVarPath = `/api/v1/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof annotationCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(annotationCreate !== undefined ? annotationCreate : {})
                : (annotationCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an annotation.
         * @summary Delete Annotation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotationApiV1AnnotationsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAnnotationApiV1AnnotationsIdDelete.');
            }
            const localVarPath = `/api/v1/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get annotation by ID.
         * @summary Read Annotation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAnnotationApiV1AnnotationsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readAnnotationApiV1AnnotationsIdGet.');
            }
            const localVarPath = `/api/v1/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve annotations.
         * @summary Read Annotations
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAnnotationsApiV1AnnotationsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get shapes from annotation by ID.
         * @summary Read Shapes
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readShapesApiV1AnnotationsIdShapesGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readShapesApiV1AnnotationsIdShapesGet.');
            }
            const localVarPath = `/api/v1/annotations/{id}/shapes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an annotation.
         * @summary Update Annotation
         * @param {number} id 
         * @param {AnnotationUpdate} annotationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotationApiV1AnnotationsIdPut: async (id: number, annotationUpdate: AnnotationUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAnnotationApiV1AnnotationsIdPut.');
            }
            // verify required parameter 'annotationUpdate' is not null or undefined
            if (annotationUpdate === null || annotationUpdate === undefined) {
                throw new RequiredError('annotationUpdate','Required parameter annotationUpdate was null or undefined when calling updateAnnotationApiV1AnnotationsIdPut.');
            }
            const localVarPath = `/api/v1/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof annotationUpdate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(annotationUpdate !== undefined ? annotationUpdate : {})
                : (annotationUpdate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationsApi - functional programming interface
 * @export
 */
export const AnnotationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new annotation.
         * @summary Create Annotation
         * @param {AnnotationCreate} annotationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnotationApiV1AnnotationsPost(annotationCreate: AnnotationCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(configuration).createAnnotationApiV1AnnotationsPost(annotationCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an annotation.
         * @summary Delete Annotation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnotationApiV1AnnotationsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(configuration).deleteAnnotationApiV1AnnotationsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get annotation by ID.
         * @summary Read Annotation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAnnotationApiV1AnnotationsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(configuration).readAnnotationApiV1AnnotationsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve annotations.
         * @summary Read Annotations
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAnnotationsApiV1AnnotationsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Annotation>>> {
            const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(configuration).readAnnotationsApiV1AnnotationsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get shapes from annotation by ID.
         * @summary Read Shapes
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readShapesApiV1AnnotationsIdShapesGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shapes>> {
            const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(configuration).readShapesApiV1AnnotationsIdShapesGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an annotation.
         * @summary Update Annotation
         * @param {number} id 
         * @param {AnnotationUpdate} annotationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnotationApiV1AnnotationsIdPut(id: number, annotationUpdate: AnnotationUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await AnnotationsApiAxiosParamCreator(configuration).updateAnnotationApiV1AnnotationsIdPut(id, annotationUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AnnotationsApi - factory interface
 * @export
 */
export const AnnotationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create new annotation.
         * @summary Create Annotation
         * @param {AnnotationCreate} annotationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnotationApiV1AnnotationsPost(annotationCreate: AnnotationCreate, options?: any): AxiosPromise<Annotation> {
            return AnnotationsApiFp(configuration).createAnnotationApiV1AnnotationsPost(annotationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an annotation.
         * @summary Delete Annotation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotationApiV1AnnotationsIdDelete(id: number, options?: any): AxiosPromise<Annotation> {
            return AnnotationsApiFp(configuration).deleteAnnotationApiV1AnnotationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get annotation by ID.
         * @summary Read Annotation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAnnotationApiV1AnnotationsIdGet(id: number, options?: any): AxiosPromise<Annotation> {
            return AnnotationsApiFp(configuration).readAnnotationApiV1AnnotationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve annotations.
         * @summary Read Annotations
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAnnotationsApiV1AnnotationsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Annotation>> {
            return AnnotationsApiFp(configuration).readAnnotationsApiV1AnnotationsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get shapes from annotation by ID.
         * @summary Read Shapes
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readShapesApiV1AnnotationsIdShapesGet(id: number, options?: any): AxiosPromise<Shapes> {
            return AnnotationsApiFp(configuration).readShapesApiV1AnnotationsIdShapesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an annotation.
         * @summary Update Annotation
         * @param {number} id 
         * @param {AnnotationUpdate} annotationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotationApiV1AnnotationsIdPut(id: number, annotationUpdate: AnnotationUpdate, options?: any): AxiosPromise<Annotation> {
            return AnnotationsApiFp(configuration).updateAnnotationApiV1AnnotationsIdPut(id, annotationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationsApi - interface
 * @export
 * @interface AnnotationsApi
 */
export interface AnnotationsApiInterface {
    /**
     * Create new annotation.
     * @summary Create Annotation
     * @param {AnnotationCreate} annotationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApiInterface
     */
    createAnnotationApiV1AnnotationsPost(annotationCreate: AnnotationCreate, options?: any): AxiosPromise<Annotation>;

    /**
     * Delete an annotation.
     * @summary Delete Annotation
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApiInterface
     */
    deleteAnnotationApiV1AnnotationsIdDelete(id: number, options?: any): AxiosPromise<Annotation>;

    /**
     * Get annotation by ID.
     * @summary Read Annotation
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApiInterface
     */
    readAnnotationApiV1AnnotationsIdGet(id: number, options?: any): AxiosPromise<Annotation>;

    /**
     * Retrieve annotations.
     * @summary Read Annotations
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApiInterface
     */
    readAnnotationsApiV1AnnotationsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Annotation>>;

    /**
     * Get shapes from annotation by ID.
     * @summary Read Shapes
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApiInterface
     */
    readShapesApiV1AnnotationsIdShapesGet(id: number, options?: any): AxiosPromise<Shapes>;

    /**
     * Update an annotation.
     * @summary Update Annotation
     * @param {number} id 
     * @param {AnnotationUpdate} annotationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApiInterface
     */
    updateAnnotationApiV1AnnotationsIdPut(id: number, annotationUpdate: AnnotationUpdate, options?: any): AxiosPromise<Annotation>;

}

/**
 * AnnotationsApi - object-oriented interface
 * @export
 * @class AnnotationsApi
 * @extends {BaseAPI}
 */
export class AnnotationsApi extends BaseAPI implements AnnotationsApiInterface {
    /**
     * Create new annotation.
     * @summary Create Annotation
     * @param {AnnotationCreate} annotationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public createAnnotationApiV1AnnotationsPost(annotationCreate: AnnotationCreate, options?: any) {
        return AnnotationsApiFp(this.configuration).createAnnotationApiV1AnnotationsPost(annotationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an annotation.
     * @summary Delete Annotation
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public deleteAnnotationApiV1AnnotationsIdDelete(id: number, options?: any) {
        return AnnotationsApiFp(this.configuration).deleteAnnotationApiV1AnnotationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get annotation by ID.
     * @summary Read Annotation
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public readAnnotationApiV1AnnotationsIdGet(id: number, options?: any) {
        return AnnotationsApiFp(this.configuration).readAnnotationApiV1AnnotationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve annotations.
     * @summary Read Annotations
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public readAnnotationsApiV1AnnotationsGet(skip?: number, limit?: number, options?: any) {
        return AnnotationsApiFp(this.configuration).readAnnotationsApiV1AnnotationsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get shapes from annotation by ID.
     * @summary Read Shapes
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public readShapesApiV1AnnotationsIdShapesGet(id: number, options?: any) {
        return AnnotationsApiFp(this.configuration).readShapesApiV1AnnotationsIdShapesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an annotation.
     * @summary Update Annotation
     * @param {number} id 
     * @param {AnnotationUpdate} annotationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public updateAnnotationApiV1AnnotationsIdPut(id: number, annotationUpdate: AnnotationUpdate, options?: any) {
        return AnnotationsApiFp(this.configuration).updateAnnotationApiV1AnnotationsIdPut(id, annotationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetsApi - axios parameter creator
 * @export
 */
export const DatasetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new annotation.
         * @summary Create Annotation
         * @param {number} id 
         * @param {AnnotationCreate} annotationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnotationApiV1DatasetsIdAnnotationsPost: async (id: number, annotationCreate: AnnotationCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createAnnotationApiV1DatasetsIdAnnotationsPost.');
            }
            // verify required parameter 'annotationCreate' is not null or undefined
            if (annotationCreate === null || annotationCreate === undefined) {
                throw new RequiredError('annotationCreate','Required parameter annotationCreate was null or undefined when calling createAnnotationApiV1DatasetsIdAnnotationsPost.');
            }
            const localVarPath = `/api/v1/datasets/{id}/annotations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof annotationCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(annotationCreate !== undefined ? annotationCreate : {})
                : (annotationCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new dataset.
         * @summary Create Dataset
         * @param {DatasetCreate} datasetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetApiV1DatasetsPost: async (datasetCreate: DatasetCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasetCreate' is not null or undefined
            if (datasetCreate === null || datasetCreate === undefined) {
                throw new RequiredError('datasetCreate','Required parameter datasetCreate was null or undefined when calling createDatasetApiV1DatasetsPost.');
            }
            const localVarPath = `/api/v1/datasets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof datasetCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(datasetCreate !== undefined ? datasetCreate : {})
                : (datasetCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new segmentation.
         * @summary Create Segmentation
         * @param {number} id 
         * @param {SegmentationCreate} segmentationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSegmentationApiV1DatasetsIdSegmentationsPost: async (id: number, segmentationCreate: SegmentationCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createSegmentationApiV1DatasetsIdSegmentationsPost.');
            }
            // verify required parameter 'segmentationCreate' is not null or undefined
            if (segmentationCreate === null || segmentationCreate === undefined) {
                throw new RequiredError('segmentationCreate','Required parameter segmentationCreate was null or undefined when calling createSegmentationApiV1DatasetsIdSegmentationsPost.');
            }
            const localVarPath = `/api/v1/datasets/{id}/segmentations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof segmentationCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(segmentationCreate !== undefined ? segmentationCreate : {})
                : (segmentationCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an dataset.
         * @summary Delete Dataset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetApiV1DatasetsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDatasetApiV1DatasetsIdDelete.');
            }
            const localVarPath = `/api/v1/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve annotations.
         * @summary Read Annotations
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAnnotationsApiV1DatasetsIdAnnotationsGet: async (id: number, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readAnnotationsApiV1DatasetsIdAnnotationsGet.');
            }
            const localVarPath = `/api/v1/datasets/{id}/annotations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dataset by ID.
         * @summary Read Dataset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDatasetApiV1DatasetsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readDatasetApiV1DatasetsIdGet.');
            }
            const localVarPath = `/api/v1/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve datasets.
         * @summary Read Datasets
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDatasetsApiV1DatasetsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/datasets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve segmentations.
         * @summary Read Segmentations
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSegmentationsApiV1DatasetsIdSegmentationsGet: async (id: number, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readSegmentationsApiV1DatasetsIdSegmentationsGet.');
            }
            const localVarPath = `/api/v1/datasets/{id}/segmentations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an dataset.
         * @summary Update Dataset
         * @param {number} id 
         * @param {DatasetUpdate} datasetUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetApiV1DatasetsIdPut: async (id: number, datasetUpdate: DatasetUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDatasetApiV1DatasetsIdPut.');
            }
            // verify required parameter 'datasetUpdate' is not null or undefined
            if (datasetUpdate === null || datasetUpdate === undefined) {
                throw new RequiredError('datasetUpdate','Required parameter datasetUpdate was null or undefined when calling updateDatasetApiV1DatasetsIdPut.');
            }
            const localVarPath = `/api/v1/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof datasetUpdate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(datasetUpdate !== undefined ? datasetUpdate : {})
                : (datasetUpdate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetsApi - functional programming interface
 * @export
 */
export const DatasetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new annotation.
         * @summary Create Annotation
         * @param {number} id 
         * @param {AnnotationCreate} annotationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnotationApiV1DatasetsIdAnnotationsPost(id: number, annotationCreate: AnnotationCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).createAnnotationApiV1DatasetsIdAnnotationsPost(id, annotationCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new dataset.
         * @summary Create Dataset
         * @param {DatasetCreate} datasetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatasetApiV1DatasetsPost(datasetCreate: DatasetCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).createDatasetApiV1DatasetsPost(datasetCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new segmentation.
         * @summary Create Segmentation
         * @param {number} id 
         * @param {SegmentationCreate} segmentationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSegmentationApiV1DatasetsIdSegmentationsPost(id: number, segmentationCreate: SegmentationCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segmentation>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).createSegmentationApiV1DatasetsIdSegmentationsPost(id, segmentationCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an dataset.
         * @summary Delete Dataset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatasetApiV1DatasetsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).deleteDatasetApiV1DatasetsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve annotations.
         * @summary Read Annotations
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAnnotationsApiV1DatasetsIdAnnotationsGet(id: number, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Annotation>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).readAnnotationsApiV1DatasetsIdAnnotationsGet(id, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get dataset by ID.
         * @summary Read Dataset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDatasetApiV1DatasetsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).readDatasetApiV1DatasetsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve datasets.
         * @summary Read Datasets
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDatasetsApiV1DatasetsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).readDatasetsApiV1DatasetsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve segmentations.
         * @summary Read Segmentations
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSegmentationsApiV1DatasetsIdSegmentationsGet(id: number, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segmentation>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).readSegmentationsApiV1DatasetsIdSegmentationsGet(id, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an dataset.
         * @summary Update Dataset
         * @param {number} id 
         * @param {DatasetUpdate} datasetUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDatasetApiV1DatasetsIdPut(id: number, datasetUpdate: DatasetUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).updateDatasetApiV1DatasetsIdPut(id, datasetUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DatasetsApi - factory interface
 * @export
 */
export const DatasetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create new annotation.
         * @summary Create Annotation
         * @param {number} id 
         * @param {AnnotationCreate} annotationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnotationApiV1DatasetsIdAnnotationsPost(id: number, annotationCreate: AnnotationCreate, options?: any): AxiosPromise<Annotation> {
            return DatasetsApiFp(configuration).createAnnotationApiV1DatasetsIdAnnotationsPost(id, annotationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new dataset.
         * @summary Create Dataset
         * @param {DatasetCreate} datasetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetApiV1DatasetsPost(datasetCreate: DatasetCreate, options?: any): AxiosPromise<Dataset> {
            return DatasetsApiFp(configuration).createDatasetApiV1DatasetsPost(datasetCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new segmentation.
         * @summary Create Segmentation
         * @param {number} id 
         * @param {SegmentationCreate} segmentationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSegmentationApiV1DatasetsIdSegmentationsPost(id: number, segmentationCreate: SegmentationCreate, options?: any): AxiosPromise<Segmentation> {
            return DatasetsApiFp(configuration).createSegmentationApiV1DatasetsIdSegmentationsPost(id, segmentationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an dataset.
         * @summary Delete Dataset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetApiV1DatasetsIdDelete(id: number, options?: any): AxiosPromise<Dataset> {
            return DatasetsApiFp(configuration).deleteDatasetApiV1DatasetsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve annotations.
         * @summary Read Annotations
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAnnotationsApiV1DatasetsIdAnnotationsGet(id: number, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Annotation>> {
            return DatasetsApiFp(configuration).readAnnotationsApiV1DatasetsIdAnnotationsGet(id, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dataset by ID.
         * @summary Read Dataset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDatasetApiV1DatasetsIdGet(id: number, options?: any): AxiosPromise<Dataset> {
            return DatasetsApiFp(configuration).readDatasetApiV1DatasetsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve datasets.
         * @summary Read Datasets
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDatasetsApiV1DatasetsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Dataset>> {
            return DatasetsApiFp(configuration).readDatasetsApiV1DatasetsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve segmentations.
         * @summary Read Segmentations
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSegmentationsApiV1DatasetsIdSegmentationsGet(id: number, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Segmentation>> {
            return DatasetsApiFp(configuration).readSegmentationsApiV1DatasetsIdSegmentationsGet(id, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an dataset.
         * @summary Update Dataset
         * @param {number} id 
         * @param {DatasetUpdate} datasetUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetApiV1DatasetsIdPut(id: number, datasetUpdate: DatasetUpdate, options?: any): AxiosPromise<Dataset> {
            return DatasetsApiFp(configuration).updateDatasetApiV1DatasetsIdPut(id, datasetUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetsApi - interface
 * @export
 * @interface DatasetsApi
 */
export interface DatasetsApiInterface {
    /**
     * Create new annotation.
     * @summary Create Annotation
     * @param {number} id 
     * @param {AnnotationCreate} annotationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    createAnnotationApiV1DatasetsIdAnnotationsPost(id: number, annotationCreate: AnnotationCreate, options?: any): AxiosPromise<Annotation>;

    /**
     * Create new dataset.
     * @summary Create Dataset
     * @param {DatasetCreate} datasetCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    createDatasetApiV1DatasetsPost(datasetCreate: DatasetCreate, options?: any): AxiosPromise<Dataset>;

    /**
     * Create new segmentation.
     * @summary Create Segmentation
     * @param {number} id 
     * @param {SegmentationCreate} segmentationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    createSegmentationApiV1DatasetsIdSegmentationsPost(id: number, segmentationCreate: SegmentationCreate, options?: any): AxiosPromise<Segmentation>;

    /**
     * Delete an dataset.
     * @summary Delete Dataset
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    deleteDatasetApiV1DatasetsIdDelete(id: number, options?: any): AxiosPromise<Dataset>;

    /**
     * Retrieve annotations.
     * @summary Read Annotations
     * @param {number} id 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    readAnnotationsApiV1DatasetsIdAnnotationsGet(id: number, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Annotation>>;

    /**
     * Get dataset by ID.
     * @summary Read Dataset
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    readDatasetApiV1DatasetsIdGet(id: number, options?: any): AxiosPromise<Dataset>;

    /**
     * Retrieve datasets.
     * @summary Read Datasets
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    readDatasetsApiV1DatasetsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Dataset>>;

    /**
     * Retrieve segmentations.
     * @summary Read Segmentations
     * @param {number} id 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    readSegmentationsApiV1DatasetsIdSegmentationsGet(id: number, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Segmentation>>;

    /**
     * Update an dataset.
     * @summary Update Dataset
     * @param {number} id 
     * @param {DatasetUpdate} datasetUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApiInterface
     */
    updateDatasetApiV1DatasetsIdPut(id: number, datasetUpdate: DatasetUpdate, options?: any): AxiosPromise<Dataset>;

}

/**
 * DatasetsApi - object-oriented interface
 * @export
 * @class DatasetsApi
 * @extends {BaseAPI}
 */
export class DatasetsApi extends BaseAPI implements DatasetsApiInterface {
    /**
     * Create new annotation.
     * @summary Create Annotation
     * @param {number} id 
     * @param {AnnotationCreate} annotationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public createAnnotationApiV1DatasetsIdAnnotationsPost(id: number, annotationCreate: AnnotationCreate, options?: any) {
        return DatasetsApiFp(this.configuration).createAnnotationApiV1DatasetsIdAnnotationsPost(id, annotationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new dataset.
     * @summary Create Dataset
     * @param {DatasetCreate} datasetCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public createDatasetApiV1DatasetsPost(datasetCreate: DatasetCreate, options?: any) {
        return DatasetsApiFp(this.configuration).createDatasetApiV1DatasetsPost(datasetCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new segmentation.
     * @summary Create Segmentation
     * @param {number} id 
     * @param {SegmentationCreate} segmentationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public createSegmentationApiV1DatasetsIdSegmentationsPost(id: number, segmentationCreate: SegmentationCreate, options?: any) {
        return DatasetsApiFp(this.configuration).createSegmentationApiV1DatasetsIdSegmentationsPost(id, segmentationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an dataset.
     * @summary Delete Dataset
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public deleteDatasetApiV1DatasetsIdDelete(id: number, options?: any) {
        return DatasetsApiFp(this.configuration).deleteDatasetApiV1DatasetsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve annotations.
     * @summary Read Annotations
     * @param {number} id 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public readAnnotationsApiV1DatasetsIdAnnotationsGet(id: number, skip?: number, limit?: number, options?: any) {
        return DatasetsApiFp(this.configuration).readAnnotationsApiV1DatasetsIdAnnotationsGet(id, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dataset by ID.
     * @summary Read Dataset
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public readDatasetApiV1DatasetsIdGet(id: number, options?: any) {
        return DatasetsApiFp(this.configuration).readDatasetApiV1DatasetsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve datasets.
     * @summary Read Datasets
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public readDatasetsApiV1DatasetsGet(skip?: number, limit?: number, options?: any) {
        return DatasetsApiFp(this.configuration).readDatasetsApiV1DatasetsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve segmentations.
     * @summary Read Segmentations
     * @param {number} id 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public readSegmentationsApiV1DatasetsIdSegmentationsGet(id: number, skip?: number, limit?: number, options?: any) {
        return DatasetsApiFp(this.configuration).readSegmentationsApiV1DatasetsIdSegmentationsGet(id, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an dataset.
     * @summary Update Dataset
     * @param {number} id 
     * @param {DatasetUpdate} datasetUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public updateDatasetApiV1DatasetsIdPut(id: number, datasetUpdate: DatasetUpdate, options?: any) {
        return DatasetsApiFp(this.configuration).updateDatasetApiV1DatasetsIdPut(id, datasetUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new item.
         * @summary Create Item
         * @param {ItemCreate} itemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiV1ItemsPost: async (itemCreate: ItemCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemCreate' is not null or undefined
            if (itemCreate === null || itemCreate === undefined) {
                throw new RequiredError('itemCreate','Required parameter itemCreate was null or undefined when calling createItemApiV1ItemsPost.');
            }
            const localVarPath = `/api/v1/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof itemCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(itemCreate !== undefined ? itemCreate : {})
                : (itemCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an item.
         * @summary Delete Item
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiV1ItemsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteItemApiV1ItemsIdDelete.');
            }
            const localVarPath = `/api/v1/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get item by ID.
         * @summary Read Item
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemApiV1ItemsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readItemApiV1ItemsIdGet.');
            }
            const localVarPath = `/api/v1/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve items.
         * @summary Read Items
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsApiV1ItemsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an item.
         * @summary Update Item
         * @param {number} id 
         * @param {ItemUpdate} itemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiV1ItemsIdPut: async (id: number, itemUpdate: ItemUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateItemApiV1ItemsIdPut.');
            }
            // verify required parameter 'itemUpdate' is not null or undefined
            if (itemUpdate === null || itemUpdate === undefined) {
                throw new RequiredError('itemUpdate','Required parameter itemUpdate was null or undefined when calling updateItemApiV1ItemsIdPut.');
            }
            const localVarPath = `/api/v1/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof itemUpdate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(itemUpdate !== undefined ? itemUpdate : {})
                : (itemUpdate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new item.
         * @summary Create Item
         * @param {ItemCreate} itemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiV1ItemsPost(itemCreate: ItemCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).createItemApiV1ItemsPost(itemCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an item.
         * @summary Delete Item
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiV1ItemsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).deleteItemApiV1ItemsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get item by ID.
         * @summary Read Item
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemApiV1ItemsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).readItemApiV1ItemsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve items.
         * @summary Read Items
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsApiV1ItemsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).readItemsApiV1ItemsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an item.
         * @summary Update Item
         * @param {number} id 
         * @param {ItemUpdate} itemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiV1ItemsIdPut(id: number, itemUpdate: ItemUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).updateItemApiV1ItemsIdPut(id, itemUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create new item.
         * @summary Create Item
         * @param {ItemCreate} itemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiV1ItemsPost(itemCreate: ItemCreate, options?: any): AxiosPromise<Item> {
            return ItemsApiFp(configuration).createItemApiV1ItemsPost(itemCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an item.
         * @summary Delete Item
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiV1ItemsIdDelete(id: number, options?: any): AxiosPromise<Item> {
            return ItemsApiFp(configuration).deleteItemApiV1ItemsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get item by ID.
         * @summary Read Item
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemApiV1ItemsIdGet(id: number, options?: any): AxiosPromise<Item> {
            return ItemsApiFp(configuration).readItemApiV1ItemsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve items.
         * @summary Read Items
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsApiV1ItemsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Item>> {
            return ItemsApiFp(configuration).readItemsApiV1ItemsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an item.
         * @summary Update Item
         * @param {number} id 
         * @param {ItemUpdate} itemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiV1ItemsIdPut(id: number, itemUpdate: ItemUpdate, options?: any): AxiosPromise<Item> {
            return ItemsApiFp(configuration).updateItemApiV1ItemsIdPut(id, itemUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - interface
 * @export
 * @interface ItemsApi
 */
export interface ItemsApiInterface {
    /**
     * Create new item.
     * @summary Create Item
     * @param {ItemCreate} itemCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApiInterface
     */
    createItemApiV1ItemsPost(itemCreate: ItemCreate, options?: any): AxiosPromise<Item>;

    /**
     * Delete an item.
     * @summary Delete Item
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApiInterface
     */
    deleteItemApiV1ItemsIdDelete(id: number, options?: any): AxiosPromise<Item>;

    /**
     * Get item by ID.
     * @summary Read Item
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApiInterface
     */
    readItemApiV1ItemsIdGet(id: number, options?: any): AxiosPromise<Item>;

    /**
     * Retrieve items.
     * @summary Read Items
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApiInterface
     */
    readItemsApiV1ItemsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Item>>;

    /**
     * Update an item.
     * @summary Update Item
     * @param {number} id 
     * @param {ItemUpdate} itemUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApiInterface
     */
    updateItemApiV1ItemsIdPut(id: number, itemUpdate: ItemUpdate, options?: any): AxiosPromise<Item>;

}

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI implements ItemsApiInterface {
    /**
     * Create new item.
     * @summary Create Item
     * @param {ItemCreate} itemCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemApiV1ItemsPost(itemCreate: ItemCreate, options?: any) {
        return ItemsApiFp(this.configuration).createItemApiV1ItemsPost(itemCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an item.
     * @summary Delete Item
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteItemApiV1ItemsIdDelete(id: number, options?: any) {
        return ItemsApiFp(this.configuration).deleteItemApiV1ItemsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get item by ID.
     * @summary Read Item
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemApiV1ItemsIdGet(id: number, options?: any) {
        return ItemsApiFp(this.configuration).readItemApiV1ItemsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve items.
     * @summary Read Items
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsApiV1ItemsGet(skip?: number, limit?: number, options?: any) {
        return ItemsApiFp(this.configuration).readItemsApiV1ItemsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an item.
     * @summary Update Item
     * @param {number} id 
     * @param {ItemUpdate} itemUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItemApiV1ItemsIdPut(id: number, itemUpdate: ItemUpdate, options?: any) {
        return ItemsApiFp(this.configuration).updateItemApiV1ItemsIdPut(id, itemUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessTokenApiV1LoginAccessTokenPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling loginAccessTokenApiV1LoginAccessTokenPost.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling loginAccessTokenApiV1LoginAccessTokenPost.');
            }
            const localVarPath = `/api/v1/login/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPasswordApiV1PasswordRecoveryEmailPost: async (email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling recoverPasswordApiV1PasswordRecoveryEmailPost.');
            }
            const localVarPath = `/api/v1/password-recovery/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiV1ResetPasswordPost: async (bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyResetPasswordApiV1ResetPasswordPost' is not null or undefined
            if (bodyResetPasswordApiV1ResetPasswordPost === null || bodyResetPasswordApiV1ResetPasswordPost === undefined) {
                throw new RequiredError('bodyResetPasswordApiV1ResetPasswordPost','Required parameter bodyResetPasswordApiV1ResetPasswordPost was null or undefined when calling resetPasswordApiV1ResetPasswordPost.');
            }
            const localVarPath = `/api/v1/reset-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bodyResetPasswordApiV1ResetPasswordPost !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bodyResetPasswordApiV1ResetPasswordPost !== undefined ? bodyResetPasswordApiV1ResetPasswordPost : {})
                : (bodyResetPasswordApiV1ResetPasswordPost || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testTokenApiV1LoginTestTokenPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/login/test-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).recoverPasswordApiV1PasswordRecoveryEmailPost(email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testTokenApiV1LoginTestTokenPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).testTokenApiV1LoginTestTokenPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return LoginApiFp(configuration).loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any): AxiosPromise<Msg> {
            return LoginApiFp(configuration).recoverPasswordApiV1PasswordRecoveryEmailPost(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any): AxiosPromise<Msg> {
            return LoginApiFp(configuration).resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testTokenApiV1LoginTestTokenPost(options?: any): AxiosPromise<User> {
            return LoginApiFp(configuration).testTokenApiV1LoginTestTokenPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - interface
 * @export
 * @interface LoginApi
 */
export interface LoginApiInterface {
    /**
     * OAuth2 compatible token login, get an access token for future requests
     * @summary Login Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiInterface
     */
    loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token>;

    /**
     * Password Recovery
     * @summary Recover Password
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiInterface
     */
    recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any): AxiosPromise<Msg>;

    /**
     * Reset password
     * @summary Reset Password
     * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiInterface
     */
    resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any): AxiosPromise<Msg>;

    /**
     * Test access token
     * @summary Test Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiInterface
     */
    testTokenApiV1LoginTestTokenPost(options?: any): AxiosPromise<User>;

}

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI implements LoginApiInterface {
    /**
     * OAuth2 compatible token login, get an access token for future requests
     * @summary Login Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any) {
        return LoginApiFp(this.configuration).loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Password Recovery
     * @summary Recover Password
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any) {
        return LoginApiFp(this.configuration).recoverPasswordApiV1PasswordRecoveryEmailPost(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password
     * @summary Reset Password
     * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any) {
        return LoginApiFp(this.configuration).resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test access token
     * @summary Test Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public testTokenApiV1LoginTestTokenPost(options?: any) {
        return LoginApiFp(this.configuration).testTokenApiV1LoginTestTokenPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModelsApi - axios parameter creator
 * @export
 */
export const ModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new model.
         * @summary Create Model
         * @param {ModelCreate} modelCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelApiV1ModelsPost: async (modelCreate: ModelCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelCreate' is not null or undefined
            if (modelCreate === null || modelCreate === undefined) {
                throw new RequiredError('modelCreate','Required parameter modelCreate was null or undefined when calling createModelApiV1ModelsPost.');
            }
            const localVarPath = `/api/v1/models/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof modelCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(modelCreate !== undefined ? modelCreate : {})
                : (modelCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an model.
         * @summary Delete Model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelApiV1ModelsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteModelApiV1ModelsIdDelete.');
            }
            const localVarPath = `/api/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get model by ID.
         * @summary Read Model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readModelApiV1ModelsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readModelApiV1ModelsIdGet.');
            }
            const localVarPath = `/api/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve models.
         * @summary Read Models
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readModelsApiV1ModelsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/models/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an model.
         * @summary Update Model
         * @param {number} id 
         * @param {ModelUpdate} modelUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModelApiV1ModelsIdPut: async (id: number, modelUpdate: ModelUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateModelApiV1ModelsIdPut.');
            }
            // verify required parameter 'modelUpdate' is not null or undefined
            if (modelUpdate === null || modelUpdate === undefined) {
                throw new RequiredError('modelUpdate','Required parameter modelUpdate was null or undefined when calling updateModelApiV1ModelsIdPut.');
            }
            const localVarPath = `/api/v1/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof modelUpdate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(modelUpdate !== undefined ? modelUpdate : {})
                : (modelUpdate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new model.
         * @summary Create Model
         * @param {ModelCreate} modelCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModelApiV1ModelsPost(modelCreate: ModelCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model>> {
            const localVarAxiosArgs = await ModelsApiAxiosParamCreator(configuration).createModelApiV1ModelsPost(modelCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an model.
         * @summary Delete Model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModelApiV1ModelsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model>> {
            const localVarAxiosArgs = await ModelsApiAxiosParamCreator(configuration).deleteModelApiV1ModelsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get model by ID.
         * @summary Read Model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readModelApiV1ModelsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model>> {
            const localVarAxiosArgs = await ModelsApiAxiosParamCreator(configuration).readModelApiV1ModelsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve models.
         * @summary Read Models
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readModelsApiV1ModelsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Model>>> {
            const localVarAxiosArgs = await ModelsApiAxiosParamCreator(configuration).readModelsApiV1ModelsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an model.
         * @summary Update Model
         * @param {number} id 
         * @param {ModelUpdate} modelUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModelApiV1ModelsIdPut(id: number, modelUpdate: ModelUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model>> {
            const localVarAxiosArgs = await ModelsApiAxiosParamCreator(configuration).updateModelApiV1ModelsIdPut(id, modelUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create new model.
         * @summary Create Model
         * @param {ModelCreate} modelCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelApiV1ModelsPost(modelCreate: ModelCreate, options?: any): AxiosPromise<Model> {
            return ModelsApiFp(configuration).createModelApiV1ModelsPost(modelCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an model.
         * @summary Delete Model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelApiV1ModelsIdDelete(id: number, options?: any): AxiosPromise<Model> {
            return ModelsApiFp(configuration).deleteModelApiV1ModelsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get model by ID.
         * @summary Read Model
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readModelApiV1ModelsIdGet(id: number, options?: any): AxiosPromise<Model> {
            return ModelsApiFp(configuration).readModelApiV1ModelsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve models.
         * @summary Read Models
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readModelsApiV1ModelsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Model>> {
            return ModelsApiFp(configuration).readModelsApiV1ModelsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an model.
         * @summary Update Model
         * @param {number} id 
         * @param {ModelUpdate} modelUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModelApiV1ModelsIdPut(id: number, modelUpdate: ModelUpdate, options?: any): AxiosPromise<Model> {
            return ModelsApiFp(configuration).updateModelApiV1ModelsIdPut(id, modelUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelsApi - interface
 * @export
 * @interface ModelsApi
 */
export interface ModelsApiInterface {
    /**
     * Create new model.
     * @summary Create Model
     * @param {ModelCreate} modelCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApiInterface
     */
    createModelApiV1ModelsPost(modelCreate: ModelCreate, options?: any): AxiosPromise<Model>;

    /**
     * Delete an model.
     * @summary Delete Model
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApiInterface
     */
    deleteModelApiV1ModelsIdDelete(id: number, options?: any): AxiosPromise<Model>;

    /**
     * Get model by ID.
     * @summary Read Model
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApiInterface
     */
    readModelApiV1ModelsIdGet(id: number, options?: any): AxiosPromise<Model>;

    /**
     * Retrieve models.
     * @summary Read Models
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApiInterface
     */
    readModelsApiV1ModelsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Model>>;

    /**
     * Update an model.
     * @summary Update Model
     * @param {number} id 
     * @param {ModelUpdate} modelUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApiInterface
     */
    updateModelApiV1ModelsIdPut(id: number, modelUpdate: ModelUpdate, options?: any): AxiosPromise<Model>;

}

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class ModelsApi
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI implements ModelsApiInterface {
    /**
     * Create new model.
     * @summary Create Model
     * @param {ModelCreate} modelCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public createModelApiV1ModelsPost(modelCreate: ModelCreate, options?: any) {
        return ModelsApiFp(this.configuration).createModelApiV1ModelsPost(modelCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an model.
     * @summary Delete Model
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public deleteModelApiV1ModelsIdDelete(id: number, options?: any) {
        return ModelsApiFp(this.configuration).deleteModelApiV1ModelsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get model by ID.
     * @summary Read Model
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public readModelApiV1ModelsIdGet(id: number, options?: any) {
        return ModelsApiFp(this.configuration).readModelApiV1ModelsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve models.
     * @summary Read Models
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public readModelsApiV1ModelsGet(skip?: number, limit?: number, options?: any) {
        return ModelsApiFp(this.configuration).readModelsApiV1ModelsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an model.
     * @summary Update Model
     * @param {number} id 
     * @param {ModelUpdate} modelUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public updateModelApiV1ModelsIdPut(id: number, modelUpdate: ModelUpdate, options?: any) {
        return ModelsApiFp(this.configuration).updateModelApiV1ModelsIdPut(id, modelUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new dataset for project.
         * @summary Create Dataset
         * @param {number} id 
         * @param {DatasetCreate} datasetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetApiV1ProjectsIdDatasetsPost: async (id: number, datasetCreate: DatasetCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createDatasetApiV1ProjectsIdDatasetsPost.');
            }
            // verify required parameter 'datasetCreate' is not null or undefined
            if (datasetCreate === null || datasetCreate === undefined) {
                throw new RequiredError('datasetCreate','Required parameter datasetCreate was null or undefined when calling createDatasetApiV1ProjectsIdDatasetsPost.');
            }
            const localVarPath = `/api/v1/projects/{id}/datasets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof datasetCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(datasetCreate !== undefined ? datasetCreate : {})
                : (datasetCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new model for project.
         * @summary Create Model
         * @param {number} id 
         * @param {ModelCreate} modelCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelApiV1ProjectsIdModelsPost: async (id: number, modelCreate: ModelCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createModelApiV1ProjectsIdModelsPost.');
            }
            // verify required parameter 'modelCreate' is not null or undefined
            if (modelCreate === null || modelCreate === undefined) {
                throw new RequiredError('modelCreate','Required parameter modelCreate was null or undefined when calling createModelApiV1ProjectsIdModelsPost.');
            }
            const localVarPath = `/api/v1/projects/{id}/models`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof modelCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(modelCreate !== undefined ? modelCreate : {})
                : (modelCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new project.
         * @summary Create Project
         * @param {ProjectCreate} projectCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectApiV1ProjectsPost: async (projectCreate: ProjectCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectCreate' is not null or undefined
            if (projectCreate === null || projectCreate === undefined) {
                throw new RequiredError('projectCreate','Required parameter projectCreate was null or undefined when calling createProjectApiV1ProjectsPost.');
            }
            const localVarPath = `/api/v1/projects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof projectCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(projectCreate !== undefined ? projectCreate : {})
                : (projectCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an project.
         * @summary Delete Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectApiV1ProjectsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProjectApiV1ProjectsIdDelete.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve datasets for project.
         * @summary Read Datasets
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDatasetsApiV1ProjectsIdDatasetsGet: async (id: number, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readDatasetsApiV1ProjectsIdDatasetsGet.');
            }
            const localVarPath = `/api/v1/projects/{id}/datasets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve models for project.
         * @summary Read Models
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readModelsApiV1ProjectsIdModelsGet: async (id: number, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readModelsApiV1ProjectsIdModelsGet.');
            }
            const localVarPath = `/api/v1/projects/{id}/models`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get project by ID.
         * @summary Read Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectApiV1ProjectsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readProjectApiV1ProjectsIdGet.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve projects.
         * @summary Read Projects
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectsApiV1ProjectsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an project.
         * @summary Update Project
         * @param {number} id 
         * @param {ProjectUpdate} projectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectApiV1ProjectsIdPut: async (id: number, projectUpdate: ProjectUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProjectApiV1ProjectsIdPut.');
            }
            // verify required parameter 'projectUpdate' is not null or undefined
            if (projectUpdate === null || projectUpdate === undefined) {
                throw new RequiredError('projectUpdate','Required parameter projectUpdate was null or undefined when calling updateProjectApiV1ProjectsIdPut.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof projectUpdate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(projectUpdate !== undefined ? projectUpdate : {})
                : (projectUpdate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new dataset for project.
         * @summary Create Dataset
         * @param {number} id 
         * @param {DatasetCreate} datasetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatasetApiV1ProjectsIdDatasetsPost(id: number, datasetCreate: DatasetCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).createDatasetApiV1ProjectsIdDatasetsPost(id, datasetCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new model for project.
         * @summary Create Model
         * @param {number} id 
         * @param {ModelCreate} modelCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModelApiV1ProjectsIdModelsPost(id: number, modelCreate: ModelCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).createModelApiV1ProjectsIdModelsPost(id, modelCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new project.
         * @summary Create Project
         * @param {ProjectCreate} projectCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectApiV1ProjectsPost(projectCreate: ProjectCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).createProjectApiV1ProjectsPost(projectCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an project.
         * @summary Delete Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectApiV1ProjectsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).deleteProjectApiV1ProjectsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve datasets for project.
         * @summary Read Datasets
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDatasetsApiV1ProjectsIdDatasetsGet(id: number, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).readDatasetsApiV1ProjectsIdDatasetsGet(id, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve models for project.
         * @summary Read Models
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readModelsApiV1ProjectsIdModelsGet(id: number, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Model>>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).readModelsApiV1ProjectsIdModelsGet(id, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get project by ID.
         * @summary Read Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readProjectApiV1ProjectsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).readProjectApiV1ProjectsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve projects.
         * @summary Read Projects
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readProjectsApiV1ProjectsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).readProjectsApiV1ProjectsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an project.
         * @summary Update Project
         * @param {number} id 
         * @param {ProjectUpdate} projectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectApiV1ProjectsIdPut(id: number, projectUpdate: ProjectUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).updateProjectApiV1ProjectsIdPut(id, projectUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create new dataset for project.
         * @summary Create Dataset
         * @param {number} id 
         * @param {DatasetCreate} datasetCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetApiV1ProjectsIdDatasetsPost(id: number, datasetCreate: DatasetCreate, options?: any): AxiosPromise<Dataset> {
            return ProjectsApiFp(configuration).createDatasetApiV1ProjectsIdDatasetsPost(id, datasetCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new model for project.
         * @summary Create Model
         * @param {number} id 
         * @param {ModelCreate} modelCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelApiV1ProjectsIdModelsPost(id: number, modelCreate: ModelCreate, options?: any): AxiosPromise<Dataset> {
            return ProjectsApiFp(configuration).createModelApiV1ProjectsIdModelsPost(id, modelCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new project.
         * @summary Create Project
         * @param {ProjectCreate} projectCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectApiV1ProjectsPost(projectCreate: ProjectCreate, options?: any): AxiosPromise<Project> {
            return ProjectsApiFp(configuration).createProjectApiV1ProjectsPost(projectCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an project.
         * @summary Delete Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectApiV1ProjectsIdDelete(id: number, options?: any): AxiosPromise<Project> {
            return ProjectsApiFp(configuration).deleteProjectApiV1ProjectsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve datasets for project.
         * @summary Read Datasets
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDatasetsApiV1ProjectsIdDatasetsGet(id: number, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Dataset>> {
            return ProjectsApiFp(configuration).readDatasetsApiV1ProjectsIdDatasetsGet(id, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve models for project.
         * @summary Read Models
         * @param {number} id 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readModelsApiV1ProjectsIdModelsGet(id: number, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Model>> {
            return ProjectsApiFp(configuration).readModelsApiV1ProjectsIdModelsGet(id, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get project by ID.
         * @summary Read Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectApiV1ProjectsIdGet(id: number, options?: any): AxiosPromise<Project> {
            return ProjectsApiFp(configuration).readProjectApiV1ProjectsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve projects.
         * @summary Read Projects
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectsApiV1ProjectsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Project>> {
            return ProjectsApiFp(configuration).readProjectsApiV1ProjectsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an project.
         * @summary Update Project
         * @param {number} id 
         * @param {ProjectUpdate} projectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectApiV1ProjectsIdPut(id: number, projectUpdate: ProjectUpdate, options?: any): AxiosPromise<Project> {
            return ProjectsApiFp(configuration).updateProjectApiV1ProjectsIdPut(id, projectUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - interface
 * @export
 * @interface ProjectsApi
 */
export interface ProjectsApiInterface {
    /**
     * Create new dataset for project.
     * @summary Create Dataset
     * @param {number} id 
     * @param {DatasetCreate} datasetCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    createDatasetApiV1ProjectsIdDatasetsPost(id: number, datasetCreate: DatasetCreate, options?: any): AxiosPromise<Dataset>;

    /**
     * Create new model for project.
     * @summary Create Model
     * @param {number} id 
     * @param {ModelCreate} modelCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    createModelApiV1ProjectsIdModelsPost(id: number, modelCreate: ModelCreate, options?: any): AxiosPromise<Dataset>;

    /**
     * Create new project.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    createProjectApiV1ProjectsPost(projectCreate: ProjectCreate, options?: any): AxiosPromise<Project>;

    /**
     * Delete an project.
     * @summary Delete Project
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    deleteProjectApiV1ProjectsIdDelete(id: number, options?: any): AxiosPromise<Project>;

    /**
     * Retrieve datasets for project.
     * @summary Read Datasets
     * @param {number} id 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    readDatasetsApiV1ProjectsIdDatasetsGet(id: number, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Dataset>>;

    /**
     * Retrieve models for project.
     * @summary Read Models
     * @param {number} id 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    readModelsApiV1ProjectsIdModelsGet(id: number, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Model>>;

    /**
     * Get project by ID.
     * @summary Read Project
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    readProjectApiV1ProjectsIdGet(id: number, options?: any): AxiosPromise<Project>;

    /**
     * Retrieve projects.
     * @summary Read Projects
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    readProjectsApiV1ProjectsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Project>>;

    /**
     * Update an project.
     * @summary Update Project
     * @param {number} id 
     * @param {ProjectUpdate} projectUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    updateProjectApiV1ProjectsIdPut(id: number, projectUpdate: ProjectUpdate, options?: any): AxiosPromise<Project>;

}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI implements ProjectsApiInterface {
    /**
     * Create new dataset for project.
     * @summary Create Dataset
     * @param {number} id 
     * @param {DatasetCreate} datasetCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createDatasetApiV1ProjectsIdDatasetsPost(id: number, datasetCreate: DatasetCreate, options?: any) {
        return ProjectsApiFp(this.configuration).createDatasetApiV1ProjectsIdDatasetsPost(id, datasetCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new model for project.
     * @summary Create Model
     * @param {number} id 
     * @param {ModelCreate} modelCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createModelApiV1ProjectsIdModelsPost(id: number, modelCreate: ModelCreate, options?: any) {
        return ProjectsApiFp(this.configuration).createModelApiV1ProjectsIdModelsPost(id, modelCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new project.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProjectApiV1ProjectsPost(projectCreate: ProjectCreate, options?: any) {
        return ProjectsApiFp(this.configuration).createProjectApiV1ProjectsPost(projectCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an project.
     * @summary Delete Project
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjectApiV1ProjectsIdDelete(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProjectApiV1ProjectsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve datasets for project.
     * @summary Read Datasets
     * @param {number} id 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public readDatasetsApiV1ProjectsIdDatasetsGet(id: number, skip?: number, limit?: number, options?: any) {
        return ProjectsApiFp(this.configuration).readDatasetsApiV1ProjectsIdDatasetsGet(id, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve models for project.
     * @summary Read Models
     * @param {number} id 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public readModelsApiV1ProjectsIdModelsGet(id: number, skip?: number, limit?: number, options?: any) {
        return ProjectsApiFp(this.configuration).readModelsApiV1ProjectsIdModelsGet(id, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get project by ID.
     * @summary Read Project
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public readProjectApiV1ProjectsIdGet(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).readProjectApiV1ProjectsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve projects.
     * @summary Read Projects
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public readProjectsApiV1ProjectsGet(skip?: number, limit?: number, options?: any) {
        return ProjectsApiFp(this.configuration).readProjectsApiV1ProjectsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an project.
     * @summary Update Project
     * @param {number} id 
     * @param {ProjectUpdate} projectUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProjectApiV1ProjectsIdPut(id: number, projectUpdate: ProjectUpdate, options?: any) {
        return ProjectsApiFp(this.configuration).updateProjectApiV1ProjectsIdPut(id, projectUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentationsApi - axios parameter creator
 * @export
 */
export const SegmentationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new segmentation, possibly from a model.
         * @summary Create Segmentation
         * @param {SegmentationCreate} segmentationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSegmentationApiV1SegmentationsPost: async (segmentationCreate: SegmentationCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentationCreate' is not null or undefined
            if (segmentationCreate === null || segmentationCreate === undefined) {
                throw new RequiredError('segmentationCreate','Required parameter segmentationCreate was null or undefined when calling createSegmentationApiV1SegmentationsPost.');
            }
            const localVarPath = `/api/v1/segmentations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof segmentationCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(segmentationCreate !== undefined ? segmentationCreate : {})
                : (segmentationCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an segmentation.
         * @summary Delete Segmentation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegmentationApiV1SegmentationsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSegmentationApiV1SegmentationsIdDelete.');
            }
            const localVarPath = `/api/v1/segmentations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get segmentation by ID.
         * @summary Read Segmentation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSegmentationApiV1SegmentationsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling readSegmentationApiV1SegmentationsIdGet.');
            }
            const localVarPath = `/api/v1/segmentations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve segmentations.
         * @summary Read Segmentations
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSegmentationsApiV1SegmentationsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/segmentations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an segmentation.
         * @summary Update Segmentation
         * @param {number} id 
         * @param {SegmentationUpdate} segmentationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegmentationApiV1SegmentationsIdPut: async (id: number, segmentationUpdate: SegmentationUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSegmentationApiV1SegmentationsIdPut.');
            }
            // verify required parameter 'segmentationUpdate' is not null or undefined
            if (segmentationUpdate === null || segmentationUpdate === undefined) {
                throw new RequiredError('segmentationUpdate','Required parameter segmentationUpdate was null or undefined when calling updateSegmentationApiV1SegmentationsIdPut.');
            }
            const localVarPath = `/api/v1/segmentations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof segmentationUpdate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(segmentationUpdate !== undefined ? segmentationUpdate : {})
                : (segmentationUpdate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentationsApi - functional programming interface
 * @export
 */
export const SegmentationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new segmentation, possibly from a model.
         * @summary Create Segmentation
         * @param {SegmentationCreate} segmentationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSegmentationApiV1SegmentationsPost(segmentationCreate: SegmentationCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segmentation>> {
            const localVarAxiosArgs = await SegmentationsApiAxiosParamCreator(configuration).createSegmentationApiV1SegmentationsPost(segmentationCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an segmentation.
         * @summary Delete Segmentation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegmentationApiV1SegmentationsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segmentation>> {
            const localVarAxiosArgs = await SegmentationsApiAxiosParamCreator(configuration).deleteSegmentationApiV1SegmentationsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get segmentation by ID.
         * @summary Read Segmentation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSegmentationApiV1SegmentationsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segmentation>> {
            const localVarAxiosArgs = await SegmentationsApiAxiosParamCreator(configuration).readSegmentationApiV1SegmentationsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve segmentations.
         * @summary Read Segmentations
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSegmentationsApiV1SegmentationsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segmentation>>> {
            const localVarAxiosArgs = await SegmentationsApiAxiosParamCreator(configuration).readSegmentationsApiV1SegmentationsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an segmentation.
         * @summary Update Segmentation
         * @param {number} id 
         * @param {SegmentationUpdate} segmentationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSegmentationApiV1SegmentationsIdPut(id: number, segmentationUpdate: SegmentationUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segmentation>> {
            const localVarAxiosArgs = await SegmentationsApiAxiosParamCreator(configuration).updateSegmentationApiV1SegmentationsIdPut(id, segmentationUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SegmentationsApi - factory interface
 * @export
 */
export const SegmentationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create new segmentation, possibly from a model.
         * @summary Create Segmentation
         * @param {SegmentationCreate} segmentationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSegmentationApiV1SegmentationsPost(segmentationCreate: SegmentationCreate, options?: any): AxiosPromise<Segmentation> {
            return SegmentationsApiFp(configuration).createSegmentationApiV1SegmentationsPost(segmentationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an segmentation.
         * @summary Delete Segmentation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegmentationApiV1SegmentationsIdDelete(id: number, options?: any): AxiosPromise<Segmentation> {
            return SegmentationsApiFp(configuration).deleteSegmentationApiV1SegmentationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get segmentation by ID.
         * @summary Read Segmentation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSegmentationApiV1SegmentationsIdGet(id: number, options?: any): AxiosPromise<Segmentation> {
            return SegmentationsApiFp(configuration).readSegmentationApiV1SegmentationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve segmentations.
         * @summary Read Segmentations
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSegmentationsApiV1SegmentationsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Segmentation>> {
            return SegmentationsApiFp(configuration).readSegmentationsApiV1SegmentationsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an segmentation.
         * @summary Update Segmentation
         * @param {number} id 
         * @param {SegmentationUpdate} segmentationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegmentationApiV1SegmentationsIdPut(id: number, segmentationUpdate: SegmentationUpdate, options?: any): AxiosPromise<Segmentation> {
            return SegmentationsApiFp(configuration).updateSegmentationApiV1SegmentationsIdPut(id, segmentationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentationsApi - interface
 * @export
 * @interface SegmentationsApi
 */
export interface SegmentationsApiInterface {
    /**
     * Create new segmentation, possibly from a model.
     * @summary Create Segmentation
     * @param {SegmentationCreate} segmentationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApiInterface
     */
    createSegmentationApiV1SegmentationsPost(segmentationCreate: SegmentationCreate, options?: any): AxiosPromise<Segmentation>;

    /**
     * Delete an segmentation.
     * @summary Delete Segmentation
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApiInterface
     */
    deleteSegmentationApiV1SegmentationsIdDelete(id: number, options?: any): AxiosPromise<Segmentation>;

    /**
     * Get segmentation by ID.
     * @summary Read Segmentation
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApiInterface
     */
    readSegmentationApiV1SegmentationsIdGet(id: number, options?: any): AxiosPromise<Segmentation>;

    /**
     * Retrieve segmentations.
     * @summary Read Segmentations
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApiInterface
     */
    readSegmentationsApiV1SegmentationsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Segmentation>>;

    /**
     * Update an segmentation.
     * @summary Update Segmentation
     * @param {number} id 
     * @param {SegmentationUpdate} segmentationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApiInterface
     */
    updateSegmentationApiV1SegmentationsIdPut(id: number, segmentationUpdate: SegmentationUpdate, options?: any): AxiosPromise<Segmentation>;

}

/**
 * SegmentationsApi - object-oriented interface
 * @export
 * @class SegmentationsApi
 * @extends {BaseAPI}
 */
export class SegmentationsApi extends BaseAPI implements SegmentationsApiInterface {
    /**
     * Create new segmentation, possibly from a model.
     * @summary Create Segmentation
     * @param {SegmentationCreate} segmentationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApi
     */
    public createSegmentationApiV1SegmentationsPost(segmentationCreate: SegmentationCreate, options?: any) {
        return SegmentationsApiFp(this.configuration).createSegmentationApiV1SegmentationsPost(segmentationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an segmentation.
     * @summary Delete Segmentation
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApi
     */
    public deleteSegmentationApiV1SegmentationsIdDelete(id: number, options?: any) {
        return SegmentationsApiFp(this.configuration).deleteSegmentationApiV1SegmentationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get segmentation by ID.
     * @summary Read Segmentation
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApi
     */
    public readSegmentationApiV1SegmentationsIdGet(id: number, options?: any) {
        return SegmentationsApiFp(this.configuration).readSegmentationApiV1SegmentationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve segmentations.
     * @summary Read Segmentations
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApi
     */
    public readSegmentationsApiV1SegmentationsGet(skip?: number, limit?: number, options?: any) {
        return SegmentationsApiFp(this.configuration).readSegmentationsApiV1SegmentationsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an segmentation.
     * @summary Update Segmentation
     * @param {number} id 
     * @param {SegmentationUpdate} segmentationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentationsApi
     */
    public updateSegmentationApiV1SegmentationsIdPut(id: number, segmentationUpdate: SegmentationUpdate, options?: any) {
        return SegmentationsApiFp(this.configuration).updateSegmentationApiV1SegmentationsIdPut(id, segmentationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserApiV1UsersPost: async (userCreate: UserCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            if (userCreate === null || userCreate === undefined) {
                throw new RequiredError('userCreate','Required parameter userCreate was null or undefined when calling createUserApiV1UsersPost.');
            }
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userCreate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userCreate !== undefined ? userCreate : {})
                : (userCreate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserOpenApiV1UsersOpenPost: async (bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateUserOpenApiV1UsersOpenPost' is not null or undefined
            if (bodyCreateUserOpenApiV1UsersOpenPost === null || bodyCreateUserOpenApiV1UsersOpenPost === undefined) {
                throw new RequiredError('bodyCreateUserOpenApiV1UsersOpenPost','Required parameter bodyCreateUserOpenApiV1UsersOpenPost was null or undefined when calling createUserOpenApiV1UsersOpenPost.');
            }
            const localVarPath = `/api/v1/users/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bodyCreateUserOpenApiV1UsersOpenPost !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bodyCreateUserOpenApiV1UsersOpenPost !== undefined ? bodyCreateUserOpenApiV1UsersOpenPost : {})
                : (bodyCreateUserOpenApiV1UsersOpenPost || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserByIdApiV1UsersUserIdGet: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling readUserByIdApiV1UsersUserIdGet.');
            }
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMeApiV1UsersMeGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersApiV1UsersGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserApiV1UsersUserIdPut: async (userId: number, userUpdate: UserUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserApiV1UsersUserIdPut.');
            }
            // verify required parameter 'userUpdate' is not null or undefined
            if (userUpdate === null || userUpdate === undefined) {
                throw new RequiredError('userUpdate','Required parameter userUpdate was null or undefined when calling updateUserApiV1UsersUserIdPut.');
            }
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userUpdate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userUpdate !== undefined ? userUpdate : {})
                : (userUpdate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMeApiV1UsersMePut: async (bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bodyUpdateUserMeApiV1UsersMePut !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bodyUpdateUserMeApiV1UsersMePut !== undefined ? bodyUpdateUserMeApiV1UsersMePut : {})
                : (bodyUpdateUserMeApiV1UsersMePut || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserApiV1UsersPost(userCreate: UserCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).createUserApiV1UsersPost(userCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserByIdApiV1UsersUserIdGet(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).readUserByIdApiV1UsersUserIdGet(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserMeApiV1UsersMeGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).readUserMeApiV1UsersMeGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).readUsersApiV1UsersGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserApiV1UsersUserIdPut(userId, userUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserApiV1UsersPost(userCreate: UserCreate, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).createUserApiV1UsersPost(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserByIdApiV1UsersUserIdGet(userId: number, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).readUserByIdApiV1UsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMeApiV1UsersMeGet(options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).readUserMeApiV1UsersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return UsersApiFp(configuration).readUsersApiV1UsersGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).updateUserApiV1UsersUserIdPut(userId, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Create new user.
     * @summary Create User
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    createUserApiV1UsersPost(userCreate: UserCreate, options?: any): AxiosPromise<User>;

    /**
     * Create new user without the need to be logged in.
     * @summary Create User Open
     * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any): AxiosPromise<User>;

    /**
     * Get a specific user by id.
     * @summary Read User By Id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    readUserByIdApiV1UsersUserIdGet(userId: number, options?: any): AxiosPromise<User>;

    /**
     * Get current user.
     * @summary Read User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    readUserMeApiV1UsersMeGet(options?: any): AxiosPromise<User>;

    /**
     * Retrieve users.
     * @summary Read Users
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>>;

    /**
     * Update a user.
     * @summary Update User
     * @param {number} userId 
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any): AxiosPromise<User>;

    /**
     * Update own user.
     * @summary Update User Me
     * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any): AxiosPromise<User>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Create new user.
     * @summary Create User
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserApiV1UsersPost(userCreate: UserCreate, options?: any) {
        return UsersApiFp(this.configuration).createUserApiV1UsersPost(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new user without the need to be logged in.
     * @summary Create User Open
     * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any) {
        return UsersApiFp(this.configuration).createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific user by id.
     * @summary Read User By Id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserByIdApiV1UsersUserIdGet(userId: number, options?: any) {
        return UsersApiFp(this.configuration).readUserByIdApiV1UsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user.
     * @summary Read User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserMeApiV1UsersMeGet(options?: any) {
        return UsersApiFp(this.configuration).readUserMeApiV1UsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve users.
     * @summary Read Users
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).readUsersApiV1UsersGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update User
     * @param {number} userId 
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any) {
        return UsersApiFp(this.configuration).updateUserApiV1UsersUserIdPut(userId, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update own user.
     * @summary Update User Me
     * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any) {
        return UsersApiFp(this.configuration).updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UtilsApi - axios parameter creator
 * @export
 */
export const UtilsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Segment using UNet2D model.
         * @summary Infer Unet2D
         * @param {SegmentationCreateFromModel} segmentationCreateFromModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inferUnet2dApiV1UtilsInferPost: async (segmentationCreateFromModel: SegmentationCreateFromModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentationCreateFromModel' is not null or undefined
            if (segmentationCreateFromModel === null || segmentationCreateFromModel === undefined) {
                throw new RequiredError('segmentationCreateFromModel','Required parameter segmentationCreateFromModel was null or undefined when calling inferUnet2dApiV1UtilsInferPost.');
            }
            const localVarPath = `/api/v1/utils/infer/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof segmentationCreateFromModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(segmentationCreateFromModel !== undefined ? segmentationCreateFromModel : {})
                : (segmentationCreateFromModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Poll Celery task.
         * @summary Poll Task
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollTaskApiV1UtilsPollTaskPost: async (task: Task, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling pollTaskApiV1UtilsPollTaskPost.');
            }
            const localVarPath = `/api/v1/utils/poll-task/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof task !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(task !== undefined ? task : {})
                : (task || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Test Celery worker.
         * @summary Test Celery
         * @param {number} timeout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCeleryApiV1UtilsTestCeleryPost: async (timeout: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeout' is not null or undefined
            if (timeout === null || timeout === undefined) {
                throw new RequiredError('timeout','Required parameter timeout was null or undefined when calling testCeleryApiV1UtilsTestCeleryPost.');
            }
            const localVarPath = `/api/v1/utils/test-celery/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEmailApiV1UtilsTestEmailPost: async (emailTo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailTo' is not null or undefined
            if (emailTo === null || emailTo === undefined) {
                throw new RequiredError('emailTo','Required parameter emailTo was null or undefined when calling testEmailApiV1UtilsTestEmailPost.');
            }
            const localVarPath = `/api/v1/utils/test-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (emailTo !== undefined) {
                localVarQueryParameter['email_to'] = emailTo;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Test Celery worker and Pytorch.
         * @summary Test Pytorch
         * @param {Msg} msg 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPytorchApiV1UtilsTestPytorchPost: async (msg: Msg, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling testPytorchApiV1UtilsTestPytorchPost.');
            }
            const localVarPath = `/api/v1/utils/test-pytorch/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof msg !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(msg !== undefined ? msg : {})
                : (msg || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Train UNet2D model.
         * @summary Train Unet2D
         * @param {ModelCreateFromAnnotation} modelCreateFromAnnotation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainUnet2dApiV1UtilsTrainPost: async (modelCreateFromAnnotation: ModelCreateFromAnnotation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelCreateFromAnnotation' is not null or undefined
            if (modelCreateFromAnnotation === null || modelCreateFromAnnotation === undefined) {
                throw new RequiredError('modelCreateFromAnnotation','Required parameter modelCreateFromAnnotation was null or undefined when calling trainUnet2dApiV1UtilsTrainPost.');
            }
            const localVarPath = `/api/v1/utils/train/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof modelCreateFromAnnotation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(modelCreateFromAnnotation !== undefined ? modelCreateFromAnnotation : {})
                : (modelCreateFromAnnotation || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Segment using UNet2D model.
         * @summary Infer Unet2D
         * @param {SegmentationCreateFromModel} segmentationCreateFromModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inferUnet2dApiV1UtilsInferPost(segmentationCreateFromModel: SegmentationCreateFromModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await UtilsApiAxiosParamCreator(configuration).inferUnet2dApiV1UtilsInferPost(segmentationCreateFromModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Poll Celery task.
         * @summary Poll Task
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollTaskApiV1UtilsPollTaskPost(task: Task, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskState>> {
            const localVarAxiosArgs = await UtilsApiAxiosParamCreator(configuration).pollTaskApiV1UtilsPollTaskPost(task, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Test Celery worker.
         * @summary Test Celery
         * @param {number} timeout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testCeleryApiV1UtilsTestCeleryPost(timeout: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await UtilsApiAxiosParamCreator(configuration).testCeleryApiV1UtilsTestCeleryPost(timeout, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testEmailApiV1UtilsTestEmailPost(emailTo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await UtilsApiAxiosParamCreator(configuration).testEmailApiV1UtilsTestEmailPost(emailTo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Test Celery worker and Pytorch.
         * @summary Test Pytorch
         * @param {Msg} msg 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testPytorchApiV1UtilsTestPytorchPost(msg: Msg, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await UtilsApiAxiosParamCreator(configuration).testPytorchApiV1UtilsTestPytorchPost(msg, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Train UNet2D model.
         * @summary Train Unet2D
         * @param {ModelCreateFromAnnotation} modelCreateFromAnnotation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainUnet2dApiV1UtilsTrainPost(modelCreateFromAnnotation: ModelCreateFromAnnotation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await UtilsApiAxiosParamCreator(configuration).trainUnet2dApiV1UtilsTrainPost(modelCreateFromAnnotation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Segment using UNet2D model.
         * @summary Infer Unet2D
         * @param {SegmentationCreateFromModel} segmentationCreateFromModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inferUnet2dApiV1UtilsInferPost(segmentationCreateFromModel: SegmentationCreateFromModel, options?: any): AxiosPromise<Task> {
            return UtilsApiFp(configuration).inferUnet2dApiV1UtilsInferPost(segmentationCreateFromModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Poll Celery task.
         * @summary Poll Task
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollTaskApiV1UtilsPollTaskPost(task: Task, options?: any): AxiosPromise<TaskState> {
            return UtilsApiFp(configuration).pollTaskApiV1UtilsPollTaskPost(task, options).then((request) => request(axios, basePath));
        },
        /**
         * Test Celery worker.
         * @summary Test Celery
         * @param {number} timeout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCeleryApiV1UtilsTestCeleryPost(timeout: number, options?: any): AxiosPromise<Task> {
            return UtilsApiFp(configuration).testCeleryApiV1UtilsTestCeleryPost(timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEmailApiV1UtilsTestEmailPost(emailTo: string, options?: any): AxiosPromise<Msg> {
            return UtilsApiFp(configuration).testEmailApiV1UtilsTestEmailPost(emailTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Test Celery worker and Pytorch.
         * @summary Test Pytorch
         * @param {Msg} msg 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPytorchApiV1UtilsTestPytorchPost(msg: Msg, options?: any): AxiosPromise<Task> {
            return UtilsApiFp(configuration).testPytorchApiV1UtilsTestPytorchPost(msg, options).then((request) => request(axios, basePath));
        },
        /**
         * Train UNet2D model.
         * @summary Train Unet2D
         * @param {ModelCreateFromAnnotation} modelCreateFromAnnotation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainUnet2dApiV1UtilsTrainPost(modelCreateFromAnnotation: ModelCreateFromAnnotation, options?: any): AxiosPromise<Task> {
            return UtilsApiFp(configuration).trainUnet2dApiV1UtilsTrainPost(modelCreateFromAnnotation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilsApi - interface
 * @export
 * @interface UtilsApi
 */
export interface UtilsApiInterface {
    /**
     * Segment using UNet2D model.
     * @summary Infer Unet2D
     * @param {SegmentationCreateFromModel} segmentationCreateFromModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApiInterface
     */
    inferUnet2dApiV1UtilsInferPost(segmentationCreateFromModel: SegmentationCreateFromModel, options?: any): AxiosPromise<Task>;

    /**
     * Poll Celery task.
     * @summary Poll Task
     * @param {Task} task 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApiInterface
     */
    pollTaskApiV1UtilsPollTaskPost(task: Task, options?: any): AxiosPromise<TaskState>;

    /**
     * Test Celery worker.
     * @summary Test Celery
     * @param {number} timeout 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApiInterface
     */
    testCeleryApiV1UtilsTestCeleryPost(timeout: number, options?: any): AxiosPromise<Task>;

    /**
     * Test emails.
     * @summary Test Email
     * @param {string} emailTo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApiInterface
     */
    testEmailApiV1UtilsTestEmailPost(emailTo: string, options?: any): AxiosPromise<Msg>;

    /**
     * Test Celery worker and Pytorch.
     * @summary Test Pytorch
     * @param {Msg} msg 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApiInterface
     */
    testPytorchApiV1UtilsTestPytorchPost(msg: Msg, options?: any): AxiosPromise<Task>;

    /**
     * Train UNet2D model.
     * @summary Train Unet2D
     * @param {ModelCreateFromAnnotation} modelCreateFromAnnotation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApiInterface
     */
    trainUnet2dApiV1UtilsTrainPost(modelCreateFromAnnotation: ModelCreateFromAnnotation, options?: any): AxiosPromise<Task>;

}

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI implements UtilsApiInterface {
    /**
     * Segment using UNet2D model.
     * @summary Infer Unet2D
     * @param {SegmentationCreateFromModel} segmentationCreateFromModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public inferUnet2dApiV1UtilsInferPost(segmentationCreateFromModel: SegmentationCreateFromModel, options?: any) {
        return UtilsApiFp(this.configuration).inferUnet2dApiV1UtilsInferPost(segmentationCreateFromModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Poll Celery task.
     * @summary Poll Task
     * @param {Task} task 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public pollTaskApiV1UtilsPollTaskPost(task: Task, options?: any) {
        return UtilsApiFp(this.configuration).pollTaskApiV1UtilsPollTaskPost(task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test Celery worker.
     * @summary Test Celery
     * @param {number} timeout 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public testCeleryApiV1UtilsTestCeleryPost(timeout: number, options?: any) {
        return UtilsApiFp(this.configuration).testCeleryApiV1UtilsTestCeleryPost(timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test emails.
     * @summary Test Email
     * @param {string} emailTo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public testEmailApiV1UtilsTestEmailPost(emailTo: string, options?: any) {
        return UtilsApiFp(this.configuration).testEmailApiV1UtilsTestEmailPost(emailTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test Celery worker and Pytorch.
     * @summary Test Pytorch
     * @param {Msg} msg 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public testPytorchApiV1UtilsTestPytorchPost(msg: Msg, options?: any) {
        return UtilsApiFp(this.configuration).testPytorchApiV1UtilsTestPytorchPost(msg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Train UNet2D model.
     * @summary Train Unet2D
     * @param {ModelCreateFromAnnotation} modelCreateFromAnnotation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public trainUnet2dApiV1UtilsTrainPost(modelCreateFromAnnotation: ModelCreateFromAnnotation, options?: any) {
        return UtilsApiFp(this.configuration).trainUnet2dApiV1UtilsTrainPost(modelCreateFromAnnotation, options).then((request) => request(this.axios, this.basePath));
    }
}


